
/***************************************************************************
 * Example program to show off the language syntax and features.
 ***************************************************************************/


/**
 * Entry point of the program.
 */
main :: fn () {
    variable_declarations();
}


/**
 * Variable declarations are defined by the `:=` operator.
 * To the left of this operator we specify the identifier.
 * Optionally in between  `:` and `=` we can specify a type.
 * Optionally we can provide a value to the right.
 * If we do not initialize the variable we need to provide the type
 * and elide the `=` operator.
 */
variable_declarations :: fn () {
    pln("Variable Declarations:");
    
    // Variable declaration with type
    pln("Declartion with type:");
    counter: i32 = 32;
    value: f64 = 0.64;
    name: str = "sqrrl";
    pln("counter: {}, value: {}, name: {}", counter, value, name);

    // Variable declaration without type (infers to same types as above)
    pln("Declartion whitout:");
    counter := 32;
    value := 0.64;
    name := "sqrrl";
    pln("counter: {}, value: {}, name: {}", counter, value, name);

    // Uninitialized variables requires types
    pln("Declartion with type:");
    counter: i32;
    value: f64;
    name: str;
    pln("counter: {}, value: {}, name: {}", counter, value, name);
}



/**
 * Variable assignment, you can assign (mutate) variables
 * using only the `=` operator but there is also the option
 * to combine arithmetic operator during assignment using
 * the operators `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, 
 * `^=`, `<<=`, `>>=`.
 */
variable_assignments :: fn () {
    pln("Variable Assignments:");

    x := 0;
    pln("x := 0 (= {})", x);

    x = 10;
    pln("x = 10 (x = {})", x);

    x -= 5;    
    pln("x -= 5 (x = {})", x);
}


/**
 * Integer literal supports different radix types.
 * There is support for decimal, binary `0b`, octal `0o` and 
 */
integer_radix :: fn () {
    pln("Integer Radix:");

    x := 1259;
    pln("decimal: 1259 = {}", x);

    x := 0b01110110;
    pln("binary: 01110110 = {}", x);

    x := 0o241;
    pln("octal: 241 = {}", x);

    x := 0xCAFE;
    pln("hexadecimal: CAFE = {}", x);
}


/**
 * If statement with or without surrounding brackes is supported.
 */
if_statements :: fn () {
    x := 12;

    // If only one line is required you can elide brackets
    y := if x > 10 x/2 else x*2;
    assert_eq(y, 6);

    // OR
    y := if 
        x > 10 x/2 
    else 
        x*2;
    assert_eq(y, 6);
    

    // You can also include brackets
    y := if x > 10 {
        x/2
    } else {
        x*2
    };

    // You can follow else by another if statement
    y:= if x > 100
        x/3
    else if x < 10
        x*2
    else
        x/2;
    assert_eq(y, 6);

    // Of course you can also include brackets here aswell
    y:= if x > 100 {
        x/3
    } else if x < 10 {
        x*2
    } else {
        x/2
    };
    assert_eq(y, 6);
}


/**
 * For loops over iterator is supported.
 */
for_loops :: fn () {
    pln("For Loop:");
        
    // For loops are defined by an identifier and an iterable expression
    pln("for a in 0..4 pln(a);\n")
    for a in 0..4 pln(a);

    pln("---------------------");
    
    // Of cource you can also include brackets around expression
    pln("for a in 2..4 { \n pln(a); \n }");
    for a in 2..4 {
        pln(a);
    }
}


/**
 * More powerful array support, both dynamic and fixed sized variants.
 */
arrays :: fn () {
    pln("Arrays:")
    
    // Array of fixed size 10 i32 values with default values of 0
    x := [10] i32;
    pln("x := [10] i32\n-> x = {}", x);

    // Arrays can also have dynamic size
    x := [..] i32;
    pln("x := [..] i32\n-> x = {}", x);

    // Arrays can be initialized with other variables ([..] is elided)
    x := i32 {5, 3, 9, 7, 2, 8, 6, 1, 4};
    pln("x := i32 {5, 3, 9, 7, 2, 8, 6, 1, 4};\n-> x = {}", x);

    // Type can also be elided, this will infer to type i32 in this case.
    x := {5, 3, 9, 7, 2, 8, 6, 1, 4};
    pln("x := {5, 3, 9, 7, 2, 8, 6, 1, 4};\n-> x = {}", x);

    // Elements can be sorted
    y := array_quicksort(x);
    pln("y := array_quicksort(x);\n-> y = ", y);


    // Array accessing is done this way
    z := y[0..5];
    pln("z := y[0..5];\n-> z = ", z);
}


/**
 * There is support for structs. The contents of a struct is defined
 * by an identifier followed by `:`, type and optionally `=` expr.
 * The optional assignment allows for specification of defualt values.
 */
MyStruct :: struct {
    alpha: i32,
    beta: str = "beta",
    gamma: [..] char = {'h', 'e', 'l', 'l', 'o'},
}


structs :: fn () {
    x: MyStruct {
        alpha := 5,
        gamma := {'g', 'a', 'm', 'm', 'a'},
    }
}
