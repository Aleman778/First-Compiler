

/***************************************************************************
 * Example program to show off the language syntax and features.
 ***************************************************************************/


/**
 * Entry point of the program.
 */
main :: fn () {
    variable_declarations();
    variable_assignment();
    integer_radix();
    if_statements();
    for_loops();
    while_loops();
    arrays();
    structs();
}


/**
 * Variable declarations are defined by the `:=` operator.
 * To the left of this operator we specify the identifier.
 * Optionally in between  `:` and `=` we can specify a type.
 * Optionally we can provide a value to the right.
 * If we do not initialize the variable we need to provide the type
 * and elide the `=` operator.
 */
variable_declarations :: fn () {
    pln("Variable Declarations:");
    
    // Variable declaration with type
    pln("Declartion with type:");
    counter: i32 = 32;
    value: f64 = 0.64;
    name: str = "sqrrl";
    pln("counter: {}, value: {}, name: {}", counter, value, name);

    // Variable declaration without type (infers to same types as above)
    pln("Declartion whitout:");
    counter := 32;
    value := 0.64;
    name := "sqrrl";
    pln("counter: {}, value: {}, name: {}", counter, value, name);

    // Uninitialized variables requires types
    pln("Declartion with type:");
    counter: i32;
    value: f64;
    name: str;
    pln("counter: {}, value: {}, name: {}", counter, value, name);
}



/**
 * Variable assignment, you can assign (mutate) variables
 * using only the `=` operator but there is also the option
 * to combine arithmetic operator during assignment using
 * the operators `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, 
 * `^=`, `<<=`, `>>=`.
 */
variable_assignments :: fn () {
    pln("Variable Assignments:");

    x := 0;
    pln("x := 0 (= {})", x);

    x = 10;
    pln("x = 10 (x = {})", x);

    x -= 5;    
    pln("x -= 5 (x = {})", x);
}


/**
 * Integer literal supports different radix types.
 * There is support for decimal, binary `0b`, octal `0o` and 
 */
integer_radix :: fn () {
    pln("Integer Radix:");

    x := 1259;
    pln("decimal: 1259 = {}", x);

    x := 0b01110110;
    pln("binary: 01110110 = {}", x);

    x := 0o241;
    pln("octal: 241 = {}", x);

    x := 0xCAFE;
    pln("hexadecimal: CAFE = {}", x);
}


/**
 * If statement with or without surrounding brackes is supported.
 */
if_statements :: fn () {
    x := 12;

    // If only one line is required you can elide brackets
    y := if x > 10 x/2 else x*2;
    assert_eq(y, 6);

    // OR
    y := if 
        x > 10 x/2 
    else 
        x*2;
    assert_eq(y, 6);
    

    // You can also include brackets
    y := if x > 10 {
        x/2
    } else {
        x*2
    };

    // You can follow else by another if statement
    y := if x > 100
        x/3
    else if x < 10
        x*2
    else
        x/2;
    assert_eq(y, 6);

    // Of course you can also include brackets here aswell
    y := if x > 100 {
        x/3
    } else if x < 10 {
        x*2
    } else {
        x/2
    };
    assert_eq(y, 6);
}


/**
 * For loops over iterator is supported.
 */
for_loops :: fn () {
    pln("For Loop:");
        
    // For loops are defined by an identifier and an iterable expression
    pln("for a in 0..4 pln(a);\n")
    for a in 0..4 pln(a);

    pln("---------------------");
    
    // Of cource you can also include brackets around expression
    pln("for a in 2..4 { \n pln(a); \n }");
    for a in 2..4 {
        pln(a);
    }
}


/**
 * While loops are iterating as long as the condition is true.
 */
while_loops :: fn () {
    pln("While Loops:");

    // While loops are defined by a condition and loop expression
    i := 0;
    while i < 10 i += 1;
    assert_eq(i, 10);
    
    // Of cource you can also incluide brackets around expression
    i := 0;
    while i < 10 {
        pln("Iteration: {}", i);
        i += 1;
    }
    assert_eq(i, 10);
}


/**
 * Infinite loops iterates forever until break exits the loop.
 */
infinite_loops :: fn () {
    pln("Infinte Loops:");

    // Custom while loops are possible with infinite loops.
    i := 0;
    loop {
        if i < 10 {
            break;
        }
        i += 1;
    }
}


/**
 * Arrays have two variante, an array can either be fixed size,
 * or have dynamic size. Here follows examples of how both can be defined and used.
 */
arrays :: fn () {
    pln("Arrays:")
    
    // Array of fixed size 10 i32 values with default values of 0
    x : [10] i32;
    pln("x : [10] i32\n-> x = {}", x);

    // Arrays can also have dynamic size
    x : [..] i32;
    pln("x : [..] i32\n-> x = {}", x);

    // Arrays can be initialized with values
    x: [] i32 = [5, 3, 9, 7, 2, 8, 6, 1, 4];
    pln("x: [] i32 = [5, 3, 9, 7, 2, 8, 6, 1, 4];\n-> x = {}", x);

    // Type can also be elided, this will infer to type i32 in this case
    x := [5, 3, 9, 7, 2, 8, 6, 1, 4];
    pln("x := [5, 3, 9, 7, 2, 8, 6, 1, 4];\n-> x = {}", x);

    // Elements can be sorted
    y := array_quicksort(x);
    pln("y := array_quicksort(x);\n-> y = ", y);

    // Array accessing is done this way
    z := y[0..5];
    pln("z := y[0..5];\n-> z = ", z);

    // Iterating over array is simple
    for i in x pln("{}", i);
}


/**
 * Structs are defined in the same way that functions are except for
 * `fn` is changed to `struct'. Structs should use `CamelCase` instead
 * of `snake_case`. Structs contains a list of fields declared in the
 * same way we declare uninitialized variables.
 */
Vector3 :: struct {
    x: f32,
    y: f32,
    z: f32,
}


/**
 * Fields in structs can also have optionally default values
 */
MyStruct :: struct {
    alpha: i32,
    beta: f32 = 0.5,
    gamma: [5] char = ['h', 'e', 'l', 'l', 'o'],
}

/**
 * Structs can also accept parameters like functions.
 * Here is an example of struct-of-array vector of 3 floats.
 * Memory Layout: x, x, ..., x, y, y, ..., y, z, z, ..., z (#floats = 3N).
 */
SOAVector3 :: struct (N: i32) {
    x: [N] f32,
    y: [N] f32,
    z: [N] f32,
}


/**
 * This function shows uses of structs.
 */
structs :: fn () {
    // This is how structs are defined
    x := MyStruct {
        alpha: 5,
        gamma: ['g', 'a', 'm', 'm', 'a'],
    };

    // Fields in struct are acessed via the dot operator
    y = x.alpha;
    

    // Printing structs can be tedius
    pln("MyStruct: {\n\talpha = {}, \n\tbeta = {}, \n\tgamma = {} \n}", x.alpha, x.beta, x.gamma);

    // Here is a simpler debug print (similar as above)
    pln("{:#?}", x);

    soa := SOAVector3(N: i32) {
        x: [N] 
    };
}


MyEnum :: enum {
    Low,
    Mid,
    High,
}


MonsterStats :: struct {
    name: str = "Unnamed Monster",
    hp: u32,
    attack: u32 = 1,
    defence: u32 = 0,
}


Monster :: enum (MonsterStats) {
    Slime = MonsterStats {name: "Slime", hp: 10}
}


spawn_slime :: () -> Monster {
    Monsters::Slime
}
